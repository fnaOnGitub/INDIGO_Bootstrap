namespace IndigoAiWorker01;

/// <summary>
/// Ottimizza prompt generici in prompt Cursor-Ready strutturati
/// </summary>
public class PromptOptimizer
{
    private readonly ILogger<PromptOptimizer> _logger;

    public PromptOptimizer(ILogger<PromptOptimizer> logger)
    {
        _logger = logger;
    }

    /// <summary>
    /// Ottimizza un'intenzione generica dell'utente in un prompt Cursor-Ready
    /// </summary>
    public string Optimize(string userIntent)
    {
        _logger.LogInformation("Ottimizzazione prompt avviata per input di lunghezza: {Length}", userIntent.Length);

        // Analisi semantica dell'input
        var analysis = AnalyzeUserIntent(userIntent);

        // Costruisce il prompt strutturato
        var optimizedPrompt = BuildCursorPrompt(
            title: analysis.Title,
            objective: analysis.Objective,
            requirements: analysis.Requirements,
            files: analysis.FilesToCreate,
            notes: analysis.AdditionalNotes
        );

        _logger.LogInformation("Prompt ottimizzato generato con successo");

        return optimizedPrompt;
    }

    /// <summary>
    /// Costruisce un prompt Cursor-Ready strutturato
    /// </summary>
    public string BuildCursorPrompt(string title, string objective, string requirements, string files, string notes)
    {
        var timestamp = DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss");

        return $@"# TASK: {title}

**Generated by IndigoAiWorker01 PromptOptimizer**  
**Timestamp**: {timestamp} UTC  
**Status**: Ready for implementation

---

## Objective

{objective}

---

## Requirements

{requirements}

---

## Files to Create/Modify

{files}

---

## Additional Notes

{notes}

---

## Implementation Checklist

- [ ] Read and understand all requirements
- [ ] Create/modify files as specified
- [ ] Follow naming conventions and code style
- [ ] Test implementation
- [ ] Verify all requirements are met
- [ ] Update documentation if needed

---

## Expected Outcome

The implementation should satisfy all requirements listed above while maintaining code quality, readability, and following best practices.

---

*Generated by IndigoAiWorker01 PromptOptimizer v1.0*  
*Ready for Cursor AI Assistant*
";
    }

    /// <summary>
    /// Analizza l'intento dell'utente ed estrae informazioni strutturate
    /// </summary>
    private UserIntentAnalysis AnalyzeUserIntent(string userIntent)
    {
        _logger.LogInformation("Analisi semantica dell'intento utente...");

        var analysis = new UserIntentAnalysis();

        // Normalizza input
        var input = userIntent.Trim();
        var lowerInput = input.ToLowerInvariant();

        // Determina il tipo di task
        var taskType = DetermineTaskType(lowerInput);
        analysis.TaskType = taskType;

        // Estrai titolo
        analysis.Title = ExtractTitle(input, taskType);

        // Estrai obiettivo
        analysis.Objective = ExtractObjective(input, taskType);

        // Estrai requirements
        analysis.Requirements = ExtractRequirements(input, taskType);

        // Estrai file da creare
        analysis.FilesToCreate = ExtractFiles(input, taskType);

        // Estrai note aggiuntive
        analysis.AdditionalNotes = ExtractAdditionalNotes(input, taskType);

        return analysis;
    }

    /// <summary>
    /// Determina il tipo di task dall'input
    /// </summary>
    private string DetermineTaskType(string lowerInput)
    {
        if (lowerInput.Contains("wpf") || lowerInput.Contains("xaml") || lowerInput.Contains("window") || lowerInput.Contains("pagina"))
            return "UI";

        if (lowerInput.Contains("refactor") || lowerInput.Contains("refactoring") || lowerInput.Contains("migliorare"))
            return "Refactoring";

        if (lowerInput.Contains("componente") || lowerInput.Contains("component") || lowerInput.Contains("modulo"))
            return "Component";

        if (lowerInput.Contains("architettura") || lowerInput.Contains("architecture") || lowerInput.Contains("design pattern"))
            return "Architecture";

        if (lowerInput.Contains("classe") || lowerInput.Contains("class") || lowerInput.Contains("metodo") || lowerInput.Contains("function"))
            return "Code";

        if (lowerInput.Contains("api") || lowerInput.Contains("endpoint") || lowerInput.Contains("controller"))
            return "API";

        return "General";
    }

    /// <summary>
    /// Estrae un titolo descrittivo
    /// </summary>
    private string ExtractTitle(string input, string taskType)
    {
        // Prende le prime parole o una sintesi
        var words = input.Split(' ').Take(8);
        var title = string.Join(" ", words);

        if (title.Length > 60)
            title = title.Substring(0, 57) + "...";

        return $"{taskType}: {title}";
    }

    /// <summary>
    /// Estrae l'obiettivo principale
    /// </summary>
    private string ExtractObjective(string input, string taskType)
    {
        var objective = $"Implementare: {input}\n\n";

        objective += taskType switch
        {
            "UI" => "Creare un'interfaccia utente seguendo i principi di UX design e le best practices WPF/XAML.",
            "Refactoring" => "Migliorare il codice esistente mantenendo la funzionalità originale, ottimizzando struttura e leggibilità.",
            "Component" => "Sviluppare un componente riusabile, modulare e ben testabile.",
            "Architecture" => "Progettare una soluzione architettonica scalabile e manutenibile.",
            "Code" => "Implementare codice pulito, ben documentato e seguendo i principi SOLID.",
            "API" => "Creare endpoint API RESTful con validazione input, gestione errori e documentazione.",
            _ => "Implementare la soluzione richiesta seguendo le best practices e garantendo qualità del codice."
        };

        return objective;
    }

    /// <summary>
    /// Estrae i requisiti dettagliati
    /// </summary>
    private string ExtractRequirements(string input, string taskType)
    {
        var requirements = new List<string>();

        // Requirements generali basati sul tipo
        switch (taskType)
        {
            case "UI":
                requirements.Add("- Utilizzare MVVM pattern");
                requirements.Add("- Binding properties con INotifyPropertyChanged");
                requirements.Add("- Stile coerente con l'applicazione esistente");
                requirements.Add("- Responsive design e gestione errori UI");
                break;

            case "Code":
                requirements.Add("- Codice pulito e leggibile");
                requirements.Add("- Commenti XML per metodi pubblici");
                requirements.Add("- Gestione errori con try-catch appropriati");
                requirements.Add("- Validazione input");
                break;

            case "Component":
                requirements.Add("- Design modulare e riusabile");
                requirements.Add("- Dependency Injection dove appropriato");
                requirements.Add("- Interfacce per astrazione");
                requirements.Add("- Unit test se necessario");
                break;

            case "API":
                requirements.Add("- RESTful design");
                requirements.Add("- Validazione input");
                requirements.Add("- Gestione errori con status code appropriati");
                requirements.Add("- Documentazione endpoint (Swagger)");
                break;

            default:
                requirements.Add("- Implementazione completa");
                requirements.Add("- Codice ben strutturato");
                requirements.Add("- Gestione errori");
                requirements.Add("- Documentazione inline");
                break;
        }

        // Estrai requisiti specifici dall'input
        if (input.Contains("PascalCase") || input.Contains("naming"))
            requirements.Add("- Seguire naming convention PascalCase");

        if (input.Contains("async") || input.Contains("asincrono"))
            requirements.Add("- Utilizzare async/await per operazioni asincrone");

        if (input.Contains("json") || input.Contains("JSON"))
            requirements.Add("- Gestire serializzazione/deserializzazione JSON");

        if (input.Contains("logging") || input.Contains("log"))
            requirements.Add("- Implementare logging appropriato");

        // Aggiungi l'input originale come requirement principale
        requirements.Insert(0, $"- **Primary**: {input}");

        return string.Join("\n", requirements);
    }

    /// <summary>
    /// Estrae i file da creare o modificare
    /// </summary>
    private string ExtractFiles(string input, string taskType)
    {
        var files = new List<string>();

        // File basati sul tipo di task
        switch (taskType)
        {
            case "UI":
                files.Add("- `Views/NewView.xaml` (UI layout)");
                files.Add("- `ViewModels/NewViewModel.cs` (ViewModel con bindings)");
                if (input.Contains("model") || input.Contains("dto"))
                    files.Add("- `Models/NewModel.cs` (Model/DTO)");
                break;

            case "Code":
                files.Add("- `ClassName.cs` (implementazione principale)");
                if (input.Contains("interface"))
                    files.Add("- `IClassName.cs` (interfaccia)");
                break;

            case "Component":
                files.Add("- `Components/ComponentName.cs` (componente principale)");
                files.Add("- `Components/IComponentName.cs` (interfaccia)");
                break;

            case "API":
                files.Add("- `Controllers/ControllerName.cs` (controller con endpoint)");
                files.Add("- `Models/RequestModel.cs` (request DTO)");
                files.Add("- `Models/ResponseModel.cs` (response DTO)");
                break;

            default:
                files.Add("- File da creare: [specificare basandosi sul contesto]");
                break;
        }

        // Aggiungi nota per modifiche
        files.Add("\n**Note**: Modificare file esistenti se appropriato invece di crearne di nuovi.");

        return string.Join("\n", files);
    }

    /// <summary>
    /// Estrae note aggiuntive e vincoli
    /// </summary>
    private string ExtractAdditionalNotes(string input, string taskType)
    {
        var notes = new List<string>();

        // Note generali
        notes.Add($"- Task Type: **{taskType}**");
        notes.Add("- Seguire le convenzioni di codice del progetto esistente");
        notes.Add("- Testare l'implementazione prima di considerarla completa");

        // Vincoli specifici dall'input
        if (input.Contains("indigo") || input.Contains("IndigoLab"))
            notes.Add("- Utilizzare naming convention IndigoLab");

        if (input.Contains("mvvm") || input.Contains("MVVM"))
            notes.Add("- Strict MVVM pattern: no code-behind nella View");

        if (input.Contains("dependency injection") || input.Contains("DI"))
            notes.Add("- Utilizzare Dependency Injection per le dipendenze");

        if (input.Contains(".NET 8") || input.Contains("net8"))
            notes.Add("- Target framework: .NET 8.0");

        // Suggerimenti basati sul tipo
        switch (taskType)
        {
            case "UI":
                notes.Add("- Testare UI con diversi stati (loading, error, success)");
                break;
            case "API":
                notes.Add("- Testare endpoint con Swagger UI o Postman");
                break;
            case "Component":
                notes.Add("- Considerare se il componente deve essere generico/riusabile");
                break;
        }

        return string.Join("\n", notes);
    }
}

/// <summary>
/// Risultato dell'analisi dell'intento utente
/// </summary>
internal class UserIntentAnalysis
{
    public string TaskType { get; set; } = "";
    public string Title { get; set; } = "";
    public string Objective { get; set; } = "";
    public string Requirements { get; set; } = "";
    public string FilesToCreate { get; set; } = "";
    public string AdditionalNotes { get; set; } = "";
}
