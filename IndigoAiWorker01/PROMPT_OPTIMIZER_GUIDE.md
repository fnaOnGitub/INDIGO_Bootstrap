# PromptOptimizer - Guida Completa

Modulo per ottimizzare richieste generiche in prompt Cursor-Ready strutturati.

## Overview

Il **PromptOptimizer** analizza l'intento dell'utente ed estrae automaticamente:
- Obiettivo principale
- Tipo di task (UI, Code, Component, API, Architecture, etc.)
- Requisiti dettagliati
- File da creare/modificare
- Vincoli e note aggiuntive

## Architettura

```
User Intent (generic)
   ↓
PromptOptimizer.Optimize()
   ↓
AnalyzeUserIntent()
   ├── DetermineTaskType()
   ├── ExtractObjective()
   ├── ExtractRequirements()
   ├── ExtractFiles()
   └── ExtractAdditionalNotes()
   ↓
BuildCursorPrompt()
   ↓
Cursor-Ready Structured Prompt
   ↓
CursorBridge.WriteOptimizedPrompt()
   ↓
./CursorBridge/optimized-<timestamp>.md
```

## Task Types Riconosciuti

| Keyword Input | Task Type | Description |
|---------------|-----------|-------------|
| wpf, xaml, window, pagina | **UI** | Interfacce utente WPF/XAML |
| refactor, migliorare | **Refactoring** | Ottimizzazione codice esistente |
| componente, component, modulo | **Component** | Componenti riusabili |
| architettura, design pattern | **Architecture** | Design e architettura |
| classe, class, metodo, function | **Code** | Implementazione codice |
| api, endpoint, controller | **API** | Endpoint RESTful |
| (nessun match) | **General** | Task generico |

## Analisi Semantica

### ExtractObjective()

Combina l'input dell'utente con best practices per il tipo di task:

- **UI**: "Creare un'interfaccia utente seguendo i principi di UX design e le best practices WPF/XAML."
- **Code**: "Implementare codice pulito, ben documentato e seguendo i principi SOLID."
- **Component**: "Sviluppare un componente riusabile, modulare e ben testabile."
- **API**: "Creare endpoint API RESTful con validazione input, gestione errori e documentazione."

### ExtractRequirements()

Genera requirements automatici basati su:

1. **Task Type**: requirements specifici per UI, Code, Component, API
2. **Keyword Detection**: rileva vincoli dall'input
   - `PascalCase` → "Seguire naming convention PascalCase"
   - `async` → "Utilizzare async/await"
   - `json` → "Gestire serializzazione JSON"
   - `logging` → "Implementare logging appropriato"
3. **Primary Requirement**: input originale dell'utente

### ExtractFiles()

Suggerisce file basati sul task type:

- **UI**: `Views/NewView.xaml`, `ViewModels/NewViewModel.cs`, `Models/NewModel.cs`
- **Code**: `ClassName.cs`, `IClassName.cs`
- **Component**: `Components/ComponentName.cs`, `Components/IComponentName.cs`
- **API**: `Controllers/ControllerName.cs`, `Models/RequestModel.cs`, `Models/ResponseModel.cs`

### ExtractAdditionalNotes()

Rileva vincoli specifici:
- `IndigoLab` → "Utilizzare naming convention IndigoLab"
- `MVVM` → "Strict MVVM pattern: no code-behind nella View"
- `DI` → "Utilizzare Dependency Injection"
- `.NET 8` → "Target framework: .NET 8.0"

## Formato Output

Il prompt ottimizzato segue questa struttura:

```markdown
# TASK: [Type]: [Title]

**Generated by IndigoAiWorker01 PromptOptimizer**  
**Timestamp**: YYYY-MM-DD HH:mm:ss UTC  
**Status**: Ready for implementation

---

## Objective

[Descrizione obiettivo principale con best practices]

---

## Requirements

- **Primary**: [Input originale utente]
- [Requirement 1]
- [Requirement 2]
- ...

---

## Files to Create/Modify

- `Path/File1.ext` (description)
- `Path/File2.ext` (description)
- ...

**Note**: Modificare file esistenti se appropriato

---

## Additional Notes

- Task Type: **[Type]**
- [Vincolo 1]
- [Vincolo 2]
- ...

---

## Implementation Checklist

- [ ] Read and understand all requirements
- [ ] Create/modify files as specified
- [ ] Follow naming conventions and code style
- [ ] Test implementation
- [ ] Verify all requirements are met
- [ ] Update documentation if needed

---

## Expected Outcome

The implementation should satisfy all requirements listed above while maintaining code quality, readability, and following best practices.

---

*Generated by IndigoAiWorker01 PromptOptimizer v1.0*  
*Ready for Cursor AI Assistant*
```

## Esempi Reali

### Esempio 1: UI Task

**Input Utente:**
```
Voglio creare una pagina WPF per visualizzare statistiche del cluster con grafici in tempo reale usando MVVM e stile IndigoLab
```

**Output Ottimizzato:**
```markdown
# TASK: UI: Voglio creare una pagina WPF per visualizzare statistiche

**Generated by IndigoAiWorker01 PromptOptimizer**  
**Timestamp**: 2026-01-01 11:31:19 UTC  
**Status**: Ready for implementation

---

## Objective

Implementare: Voglio creare una pagina WPF per visualizzare statistiche del cluster con grafici in tempo reale usando MVVM e stile IndigoLab

Creare un'interfaccia utente seguendo i principi di UX design e le best practices WPF/XAML.

---

## Requirements

- **Primary**: Voglio creare una pagina WPF per visualizzare statistiche del cluster con grafici in tempo reale usando MVVM e stile IndigoLab
- Utilizzare MVVM pattern
- Binding properties con INotifyPropertyChanged
- Stile coerente con l'applicazione esistente
- Responsive design e gestione errori UI

---

## Files to Create/Modify

- `Views/NewView.xaml` (UI layout)
- `ViewModels/NewViewModel.cs` (ViewModel con bindings)

**Note**: Modificare file esistenti se appropriato invece di crearne di nuovi.

---

## Additional Notes

- Task Type: **UI**
- Seguire le convenzioni di codice del progetto esistente
- Testare l'implementazione prima di considerarla completa
- Utilizzare naming convention IndigoLab
- Strict MVVM pattern: no code-behind nella View
- Testare UI con diversi stati (loading, error, success)

---

## Implementation Checklist

- [ ] Read and understand all requirements
- [ ] Create/modify files as specified
- [ ] Follow naming conventions and code style
- [ ] Test implementation
- [ ] Verify all requirements are met
- [ ] Update documentation if needed

---

## Expected Outcome

The implementation should satisfy all requirements listed above while maintaining code quality, readability, and following best practices.

---

*Generated by IndigoAiWorker01 PromptOptimizer v1.0*  
*Ready for Cursor AI Assistant*
```

### Esempio 2: Code Task

**Input Utente:**
```
Crea una classe User con Id, Name, Email e validazione email usando FluentValidation in .NET 8
```

**Output Ottimizzato:**
```markdown
# TASK: Code: Crea una classe User con Id, Name, Email

**Generated by IndigoAiWorker01 PromptOptimizer**  
**Timestamp**: 2026-01-01 11:31:30 UTC  
**Status**: Ready for implementation

---

## Objective

Implementare: Crea una classe User con Id, Name, Email e validazione email usando FluentValidation in .NET 8

Implementare codice pulito, ben documentato e seguendo i principi SOLID.

---

## Requirements

- **Primary**: Crea una classe User con Id, Name, Email e validazione email usando FluentValidation in .NET 8
- Codice pulito e leggibile
- Commenti XML per metodi pubblici
- Gestione errori con try-catch appropriati
- Validazione input

---

## Files to Create/Modify

- `ClassName.cs` (implementazione principale)

**Note**: Modificare file esistenti se appropriato invece di crearne di nuovi.

---

## Additional Notes

- Task Type: **Code**
- Seguire le convenzioni di codice del progetto esistente
- Testare l'implementazione prima di considerarla completa
- Target framework: .NET 8.0

---

## Implementation Checklist

- [ ] Read and understand all requirements
- [ ] Create/modify files as specified
- [ ] Follow naming conventions and code style
- [ ] Test implementation
- [ ] Verify all requirements are met
- [ ] Update documentation if needed

---

## Expected Outcome

The implementation should satisfy all requirements listed above while maintaining code quality, readability, and following best practices.

---

*Generated by IndigoAiWorker01 PromptOptimizer v1.0*  
*Ready for Cursor AI Assistant*
```

### Esempio 3: Component Task

**Input Utente:**
```
Crea un componente per visualizzare grafici in tempo reale in WPF usando LiveCharts2
```

**Output Ottimizzato:**
```markdown
# TASK: UI: Crea un componente per visualizzare grafici in tempo

**Generated by IndigoAiWorker01 PromptOptimizer**  
**Timestamp**: 2026-01-01 11:32:42 UTC  
**Status**: Ready for implementation

---

## Objective

Implementare: Crea un componente per visualizzare grafici in tempo reale in WPF usando LiveCharts2

Creare un'interfaccia utente seguendo i principi di UX design e le best practices WPF/XAML.

---

## Requirements

- **Primary**: Crea un componente per visualizzare grafici in tempo reale in WPF usando LiveCharts2
- Utilizzare MVVM pattern
- Binding properties con INotifyPropertyChanged
- Stile coerente con l'applicazione esistente
- Responsive design e gestione errori UI

---

## Files to Create/Modify

- `Views/NewView.xaml` (UI layout)
- `ViewModels/NewViewModel.cs` (ViewModel con bindings)

**Note**: Modificare file esistenti se appropriato invece di crearne di nuovi.

---

## Additional Notes

- Task Type: **UI**
- Seguire le convenzioni di codice del progetto esistente
- Testare l'implementazione prima di considerarla completa
- Testare UI con diversi stati (loading, error, success)

---

## Implementation Checklist

- [ ] Read and understand all requirements
- [ ] Create/modify files as specified
- [ ] Follow naming conventions and code style
- [ ] Test implementation
- [ ] Verify all requirements are met
- [ ] Update documentation if needed

---

## Expected Outcome

The implementation should satisfy all requirements listed above while maintaining code quality, readability, and following best practices.

---

*Generated by IndigoAiWorker01 PromptOptimizer v1.0*  
*Ready for Cursor AI Assistant*
```

## Utilizzo

### Da Control Center UI

1. Apri Control Center UI
2. Vai su **Agents** → Seleziona **agent-orchestrator**
3. Nella sezione **Dispatch Task**:
   - **Task Name**: `optimize-prompt`
   - **Payload**: `[La tua richiesta generica]`
4. Clicca **Dispatch Task**

### Da API Diretta

```bash
# Via Orchestrator (routing automatico)
curl -X POST http://localhost:5001/dispatch \
  -H "Content-Type: application/json" \
  -d '{
    "Task": "optimize-prompt",
    "Payload": "Crea una pagina WPF per statistiche cluster"
  }'

# Diretto a IndigoAiWorker01
curl -X POST http://localhost:5005/execute \
  -H "Content-Type: application/json" \
  -d '{
    "Task": "optimize-prompt",
    "Payload": "Crea componente logger middleware ASP.NET Core"
  }'
```

### Risposta JSON

```json
{
  "Success": true,
  "Message": "AI Task executed",
  "Result": "# TASK: ...\n[prompt completo]",
  "ExecutedTask": "optimize-prompt",
  "Timestamp": "2026-01-01T11:31:19.740Z",
  "CursorFileWritten": true,
  "CursorFilePath": "C:\\...\\CursorBridge\\optimized-2026-01-01-113119.md",
  "OptimizedPrompt": "# TASK: ...\n[prompt completo]"
}
```

## File Generati

I prompt ottimizzati vengono salvati in:

```
IndigoAiWorker01/bin/Debug/net8.0/CursorBridge/
├── optimized-2026-01-01-113119.md
├── optimized-2026-01-01-113130.md
├── optimized-2026-01-01-113242.md
└── ...
```

## Lista File Ottimizzati

```bash
# Visualizza file creati
curl http://localhost:5005/cursor/bridge-files

# Response
{
  "Success": true,
  "Count": 3,
  "Files": [
    "optimized-2026-01-01-113119.md",
    "optimized-2026-01-01-113130.md",
    "optimized-2026-01-01-113242.md"
  ]
}
```

## Workflow Completo

```
1. User (Control Center UI)
   ↓
2. Orchestrator (dispatch "optimize-prompt")
   ↓
3. IsAiTask("optimize-prompt") = true
   ↓
4. IndigoAiWorker01 (riceve task)
   ↓
5. AiEngine.OptimizePrompt()
   ↓
6. PromptOptimizer.Optimize()
   ├── Analizza intento utente
   ├── Determina task type
   ├── Estrae requirements
   └── Costruisce prompt strutturato
   ↓
7. CursorBridge.WriteOptimizedPrompt()
   ↓
8. File salvato: ./CursorBridge/optimized-<timestamp>.md
   ↓
9. Cursor legge file e implementa
```

## Best Practices

### Input Efficaci

**✅ Buono:**
```
Crea una pagina WPF per visualizzare statistiche del cluster con grafici in tempo reale usando MVVM e stile IndigoLab
```

**✅ Buono:**
```
Implementa un logger middleware per ASP.NET Core che logga request method, path, status code e response time
```

**❌ Troppo generico:**
```
Crea una classe
```

**❌ Troppo dettagliato:**
```
[500 righe di specifiche dettagliate]
```

### Migliori Risultati

Per ottenere prompt ottimali, includi:
- **Cosa**: tipo di componente/feature
- **Come**: tecnologie/pattern da usare
- **Vincoli**: stile, naming, framework version
- **Contesto**: parte di quale sistema

**Esempio ottimale:**
```
Crea un componente per visualizzare metriche real-time in WPF usando LiveCharts2, MVVM pattern, stile IndigoLab, target .NET 8
```

## Integrazione con Orchestrator

### Routing Automatico

L'Orchestrator riconosce automaticamente `optimize-prompt` come task AI:

```csharp
bool IsAiTask(string task)
{
    var aiTaskTypes = new[]
    {
        "generate-code",
        "refactor-code",
        "explain-code",
        "create-component",
        "fix-snippet",
        "cursor-prompt",
        "optimize-prompt"  // ⭐ Riconosciuto
    };
    
    return aiTaskTypes.Contains(task.ToLowerInvariant());
}
```

### Test Routing

```bash
# Test 1: optimize-prompt → IndigoAiWorker01
curl -X POST http://localhost:5001/dispatch \
  -d '{"Task":"optimize-prompt","Payload":"Crea classe User"}'

# Response
{
  "Success": true,
  "Message": "Task dispatched to AI-Worker",
  "Worker": "http://localhost:5005",
  "WorkerType": "AI-Worker",
  "IsAiTask": true,
  ...
}
```

## Customizzazione

### Aggiungere Nuovi Task Types

**PromptOptimizer.cs - DetermineTaskType():**

```csharp
if (lowerInput.Contains("database") || lowerInput.Contains("entity framework"))
    return "Database";

if (lowerInput.Contains("test") || lowerInput.Contains("unit test"))
    return "Testing";
```

### Aggiungere Nuovi Requirements

**PromptOptimizer.cs - ExtractRequirements():**

```csharp
case "Database":
    requirements.Add("- Entity Framework Core");
    requirements.Add("- Migration scripts");
    requirements.Add("- Repository pattern");
    break;
```

### Aggiungere Keyword Detection

**PromptOptimizer.cs - ExtractAdditionalNotes():**

```csharp
if (input.Contains("docker") || input.Contains("container"))
    notes.Add("- Containerizzazione Docker richiesta");

if (input.Contains("redis") || input.Contains("cache"))
    notes.Add("- Implementare caching con Redis");
```

## Troubleshooting

### Problema: File non creato

**Causa**: Permessi scrittura  
**Soluzione**: Verifica permessi su `IndigoAiWorker01/bin/Debug/net8.0/CursorBridge/`

### Problema: Task type non riconosciuto

**Causa**: Keyword non presente in DetermineTaskType()  
**Soluzione**: 
1. Verifica log: `Task Type: General`
2. Aggiungi keyword in `DetermineTaskType()`

### Problema: Requirements mancanti

**Causa**: Vincoli specifici non rilevati  
**Soluzione**: Aggiungi keyword detection in `ExtractRequirements()` o `ExtractAdditionalNotes()`

## Future Enhancements

### 1. Machine Learning per Task Type

```csharp
public class TaskTypeClassifier
{
    public string Classify(string input)
    {
        // ML.NET model per classificazione automatica
        var prediction = _model.Predict(input);
        return prediction.TaskType;
    }
}
```

### 2. Context-Aware Optimization

```csharp
public string Optimize(string userIntent, CodebaseContext context)
{
    // Considera file esistenti nel progetto
    var existingFiles = context.GetRelevantFiles(userIntent);
    
    // Suggerisci modifiche invece di nuovi file
    var analysis = AnalyzeUserIntent(userIntent, existingFiles);
    ...
}
```

### 3. Template Library

```csharp
public class PromptTemplates
{
    public string GetTemplate(string taskType)
    {
        return taskType switch
        {
            "UI" => LoadTemplate("templates/ui-task.md"),
            "API" => LoadTemplate("templates/api-task.md"),
            "Component" => LoadTemplate("templates/component-task.md"),
            _ => LoadTemplate("templates/default-task.md")
        };
    }
}
```

## Conclusione

Il **PromptOptimizer** trasforma richieste generiche in prompt Cursor-Ready strutturati, facilitando l'implementazione automatizzata e garantendo consistenza nel formato delle richieste AI.

---

**PromptOptimizer** - Intelligent Prompt Structuring for IndigoAiWorker01 v1.0
